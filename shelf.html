<!DOCTYPE html>
<html>
<head>
<style>
    html, body { margin:0; padding:0; background:black; height:100%; width:100%; overflow:hidden; }
    #container { display:flex; justify-content:center; align-items:center; height:100%; width:100%; background:black; position:relative; }
    .layer { position:absolute; max-width:100%; max-height:100%; object-fit:contain; user-select:none; -webkit-user-drag:none; }
    #scene { left:50%; top:50%; transform:translate(-50%,-50%); height:100%; width:auto; display:block; }
    .overlay { opacity:0; pointer-events:none; transition:opacity 0.2s ease-in-out; z-index:1005; }


    /* Items that will be positioned/scaled relative to the scene (use data-x, data-y, data-w, data-size)
       Example: <img class="item" src="pic.png" data-x="30" data-y="40" data-w="20"> */
    .item {
        position: absolute;
        z-index: 4;
        display: block;
        transform: translate(-50%, -50%);
        pointer-events: none; /* set to auto if you want items clickable */
        object-fit: contain;
        max-height: 100%;
        max-width: none; /* we'll size explicitly via JS */
    }

    /* Full-screen book overlay (hidden by default) */
    #bookOverlay {
        position: absolute;
        z-index: 999;
        transition: opacity 0.25s ease-in-out;
        opacity: 0;
        pointer-events: none;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        width: 40%;
        height: auto;
        object-fit: contain;
    }

    /* Pages inside the book */
    #bookPages { position:absolute; inset:0; pointer-events:none; z-index:998; opacity:1; }
    .page { display:none; position:absolute; inset:0; }
    .page .item { pointer-events:none; }

    #pageCounter {
        position:absolute;
        z-index:1006;
        color: white;
        font-family: sans-serif;
        font-size: 16px;
        right: 8%;
        bottom: 8%;
        transform: translate(0,0);
        pointer-events: none;
    }
</style>  
</head>
<body>

<div id="container">

    <!-- Background -->
    <img id="scene" class="layer" src="bookshelf.png">
    <img id="mask" class="layer" src="bookshelfclickmap.png" style="display:none;">

    <!-- Hover highlights -->
    <img id="highlightBookOne" class="layer overlay" src="Hibook1.png">
    <img id="highlightBack" class="layer overlay" src="HiBack.png">

    <!-- Book overlay (opens full scene when book is clicked) -->
    <img id="bookOverlay" class="layer" src="book1.png">

    <!-- Book pages: each .page contains 4 positioned .item images -->
    <div id="bookPages">
        <div class="page">
            <img class="item" src="CorkboardArchive1.png" data-x="19" data-y="15" data-w="20">
            <img class="item" src="CorkboardArchive1.png" data-x="19" data-y="65" data-w="20">
            <img class="item" src="CorkboardArchive1.png" data-x="81" data-y="15" data-w="20">
            <img class="item" src="CorkboardArchive1.png" data-x="81" data-y="65" data-w="20">
        </div>
        <div class="page">
            <img class="item" src="page2_img1.png" data-x="19" data-y="15" data-w="20">
            <img class="item" src="page2_img2.png" data-x="19" data-y="65" data-w="20">
            <img class="item" src="page2_img3.png" data-x="81" data-y="15" data-w="20">
            <img class="item" src="page2_img4.png" data-x="81" data-y="65" data-w="20">
        </div>

        <div id="pageCounter">Page 1</div>
    </div>

</div>

<script>
// Minimal clickmap & highlights + back-button and book overlay
const scene = document.getElementById("scene");
const mask = document.getElementById("mask");
const highlightBookOne = document.getElementById("highlightBookOne");
const highlightBack = document.getElementById("highlightBack");
const bookOverlay = document.getElementById("bookOverlay");

const canvas = document.createElement("canvas");
const ctx = canvas.getContext("2d");

let bookOpen = false;

function drawMaskToCanvas() {
    if (!mask.naturalWidth || !mask.naturalHeight) return;
    canvas.width = mask.naturalWidth;
    canvas.height = mask.naturalHeight;
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.drawImage(mask, 0, 0);
}

// Pages management
const bookPages = document.getElementById('bookPages');
const pages = bookPages ? Array.from(bookPages.querySelectorAll('.page')) : [];
let currentPage = 0;

function showPage(i) {
    if (!pages.length) return;
    if (i < 0 || i >= pages.length) return;
    pages.forEach(p => p.style.display = 'none');
    pages[i].style.display = 'block';
    currentPage = i;
    // position/scale only active items
    positionItems();
    scaleItems();
    const pc = document.getElementById('pageCounter');
    if (pc) pc.textContent = `Page ${currentPage + 1}`;
}

function openPages() {
    if (!pages.length) return;
    showPage(0);
    bookPages.style.pointerEvents = 'none';
}

function closePages() {
    pages.forEach(p => p.style.display = 'none');
}

function nextPage() {
    if (currentPage < pages.length - 1) showPage(currentPage + 1);
}

function prevPage() {
    if (currentPage > 0) showPage(currentPage - 1);
}

function syncHighlightsToScene() {
    const rect = scene.getBoundingClientRect();
    [highlightBookOne, highlightBack].forEach(h => {
        h.style.left = rect.left + 'px';
        h.style.top = rect.top + 'px';
        h.style.width = rect.width + 'px';
        h.style.height = rect.height + 'px';
        h.style.transform = 'none';
        h.style.pointerEvents = 'none';
        h.style.zIndex = 1005;
        h.style.display = 'block';
        h.style.visibility = 'visible';
    });
}

// Position and scale arbitrary .item elements relative to the scene image
function positionItems() {
    const rect = scene.getBoundingClientRect();
    document.querySelectorAll('.item').forEach(el => {
        const x = parseFloat(el.dataset.x) || 50;
        const y = parseFloat(el.dataset.y) || 50;
        const px = rect.left + rect.width * (x / 100);
        const py = rect.top + rect.height * (y / 100);
        el.style.left = px + 'px';
        el.style.top = py + 'px';
        el.style.transform = 'translate(-50%, -50%)';
    });
}

function scaleItems() {
    const rect = scene.getBoundingClientRect();
    const scale = scene.naturalWidth ? (rect.width / scene.naturalWidth) : 1;
    document.querySelectorAll('.item').forEach(el => {
        const w = el.dataset.w ? parseFloat(el.dataset.w) : NaN;
        if (!isNaN(w)) {
            el.style.width = (rect.width * (w / 100)) + 'px';
            el.style.height = 'auto';
        }
        const fs = el.dataset.size ? parseFloat(el.dataset.size) : NaN;
        if (!isNaN(fs)) {
            el.style.fontSize = (fs * scale) + 'px';
        }
    });
}

// Position and size the overlay to either fill the scene (full=true) or restore to centered thumbnail
function syncBookOverlayToScene(full = true) {
    const rect = scene.getBoundingClientRect();
    if (full) {
        bookOverlay.style.left = rect.left + 'px';
        bookOverlay.style.top = rect.top + 'px';
        bookOverlay.style.width = rect.width + 'px';
        bookOverlay.style.height = rect.height + 'px';
        bookOverlay.style.transform = 'none';
    } else {
        bookOverlay.style.left = '50%';
        bookOverlay.style.top = '50%';
        bookOverlay.style.transform = 'translate(-50%, -50%)';
        bookOverlay.style.width = '40%';
        bookOverlay.style.height = 'auto';
    }
}

function openBook() {
    syncBookOverlayToScene(true);
    bookOverlay.style.opacity = '1';
    // overlay is click-through so scene receives clicks; still show overlay visually
    bookOverlay.style.pointerEvents = 'none';
    bookOpen = true;
    openPages();
}

function closeBook() {
    syncBookOverlayToScene(false);
    bookOverlay.style.opacity = '0';
    bookOverlay.style.pointerEvents = 'none';
    bookOpen = false;
    closePages();
}

mask.addEventListener('load', () => { drawMaskToCanvas(); syncHighlightsToScene(); positionItems(); scaleItems(); syncBookOverlayToScene(false); attachItemLoadHandlers(); });
if (mask.complete) { drawMaskToCanvas(); syncHighlightsToScene(); positionItems(); scaleItems(); syncBookOverlayToScene(false); attachItemLoadHandlers(); }

// Also run when the scene image is ready, similar to board.html behavior
scene.addEventListener('load', () => { drawMaskToCanvas(); syncHighlightsToScene(); positionItems(); scaleItems(); syncBookOverlayToScene(false); attachItemLoadHandlers(); });
if (scene.complete) { drawMaskToCanvas(); syncHighlightsToScene(); positionItems(); scaleItems(); syncBookOverlayToScene(false); attachItemLoadHandlers(); }

function getPixelColor(e) {
    const rect = scene.getBoundingClientRect();
    const x = Math.floor((e.clientX - rect.left) * (mask.naturalWidth / rect.width));
    const y = Math.floor((e.clientY - rect.top) * (mask.naturalHeight / rect.height));
    if (x < 0 || y < 0 || x >= canvas.width || y >= canvas.height) return "0,0,0";
    const pixel = ctx.getImageData(x, y, 1, 1).data;
    return `${pixel[0]},${pixel[1]},${pixel[2]}`;
}

// Ensure item images trigger rescaling when their image data is available
function attachItemLoadHandlers() {
    document.querySelectorAll('.item').forEach(img => {
        img.addEventListener('load', () => {
            // scale and position when assets are ready
            positionItems();
            scaleItems();
        });
        // if already loaded, make sure sizing is applied
        if (img.complete) {
            positionItems();
            scaleItems();
        }
    });
}

scene.addEventListener('mousemove', (e) => {
    const color = getPixelColor(e);
    if (bookOpen) {
        // while book is open, ignore blue and only show back highlight
        highlightBookOne.style.opacity = 0;
        highlightBack.style.opacity = (color === '255,255,0') ? 1 : 0;
    } else {
        highlightBookOne.style.opacity = (color === '0,0,255') ? 1 : 0;
        highlightBack.style.opacity = (color === '255,255,0') ? 1 : 0;
    }
});
scene.addEventListener('mouseleave', () => {
    highlightBookOne.style.opacity = 0;
    highlightBack.style.opacity = 0;
});

scene.addEventListener('click', (e) => {
    const color = getPixelColor(e);

    // Back button (yellow) always takes priority
    if (color === '255,255,0') {
        if (bookOpen) {
            closeBook();
            return;
        } else {
            window.location.href = 'index.html';
            return;
        }
    }

    // If book is open, clicks on left/right halves flip pages (only if inside the scene rect)
    if (bookOpen) {
        const rect = scene.getBoundingClientRect();
        const inside = e.clientX >= rect.left && e.clientX <= rect.right && e.clientY >= rect.top && e.clientY <= rect.bottom;
        if (inside) {
            const mid = rect.left + rect.width / 2;
            if (e.clientX < mid) prevPage();
            else nextPage();
        }
        return;
    }

    // If not open and user clicked the blue book area, open it
    if (color === '0,0,255' && !bookOpen) {
        openBook();
    }
});

// Overlay is click-through; scene handles clicks while book is open

// Resize handler: keep mask canvas, highlight margins, items and overlay synced to the background
window.addEventListener('resize', () => {
    drawMaskToCanvas();
    syncHighlightsToScene();
    positionItems();
    scaleItems();
    if (bookOpen) syncBookOverlayToScene(true);
});

// Ensure layout is correct on initial load
window.addEventListener('load', () => {
    drawMaskToCanvas();
    syncHighlightsToScene();
    positionItems();
    scaleItems();
    syncBookOverlayToScene(false);
});
</script>

</body>
</html>