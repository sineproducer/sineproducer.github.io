<!DOCTYPE html>
<html>
<head>
<style>
    html, body { margin:0; padding:0; background:black; height:100%; width:100%; overflow:hidden; }
    #container { display:flex; justify-content:center; align-items:center; height:100%; width:100%; background:black; position:relative; }
    .layer { position:absolute; max-width:100%; max-height:100%; object-fit:contain; user-select:none; -webkit-user-drag:none; }
    #scene { left:50%; top:50%; transform:translate(-50%,-50%); height:100%; width:auto; display:block; }
    .overlay { opacity:0; pointer-events:none; transition:opacity 0.2s ease-in-out; z-index: 1; }


    /* Items that will be positioned/scaled relative to the scene (use data-x, data-y, data-w, data-size)
       Example: <img class="item" src="pic.png" data-x="30" data-y="40" data-w="20"> */
    .item {
        position: absolute;
        z-index: 3; /* items sit above highlight overlays */
        display: block;
        transform: translate(-50%, -50%);
        pointer-events: none; /* set to auto if you want items clickable */
        object-fit: contain;
        max-height: 100%;
        max-width: none; /* we'll size explicitly via JS */
    }

    /* Full-screen book overlay (hidden by default) */
    #bookOverlay {
        position: absolute;
        z-index: 2; /* overlay above highlights and items */
        transition: opacity 0.25s ease-in-out;
        opacity: 0;
        pointer-events: none;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        width: 40%;
        height: auto;
        object-fit: contain;
    }

    /* Scene wrapper matches visible image area and clips its contents (no overflow into margins) */
    #sceneWrapper { position:absolute; left:0; top:0; width:0; height:0; overflow:hidden; pointer-events:none; z-index:3; }

    /* Pages inside the wrapper */
    #bookPages { position:absolute; inset:0; pointer-events:none; z-index:inherit; opacity:1; }
    .page { display:none; position:absolute; inset:0; }
    .page .item { pointer-events:none; }

    #pageCounter {
        position:absolute;
        z-index: 4; /* counter above overlay and items */
        color: white;
        font-family: sans-serif;
        font-size: 16px;
        right: 8%;
        bottom: 8%;
        transform: translate(0,0);
        pointer-events: none;
    }
</style>  
</head>
<body>

<div id="container">

    <!-- Background -->
    <img id="scene" class="layer" src="bookshelf.png">
    <img id="mask" class="layer" src="bookshelfclickmap.png" style="display:none;">

    <!-- Hover highlights -->
    <img id="highlightBookOne" class="layer overlay" src="Hibook1.png">
    <img id="highlightBack" class="layer overlay" src="HiBack.png">

    <!-- Book overlay (opens full scene when book is clicked) -->
    <img id="bookOverlay" class="layer" src="book1.png">

    <!-- Scene wrapper: sized to the visible scene/overlay and clips pages -->
    <div id="sceneWrapper">
        <!-- Book pages: each .page contains 4 positioned .item images -->
        <div id="bookPages">
            <div class="page">
                <img class="item" src="CorkboardArchive1.png" data-x="19" data-y="15" data-w="20">
                <img class="item" src="CorkboardArchive1.png" data-x="19" data-y="65" data-w="20">
                <img class="item" src="CorkboardArchive1.png" data-x="81" data-y="15" data-w="20">
                <img class="item" src="CorkboardArchive1.png" data-x="81" data-y="65" data-w="20">
            </div>
            <div class="page">
                <img class="item" src="page2_img1.png" data-x="19" data-y="15" data-w="20">
                <img class="item" src="page2_img2.png" data-x="19" data-y="65" data-w="20">
                <img class="item" src="page2_img3.png" data-x="81" data-y="15" data-w="20">
                <img class="item" src="page2_img4.png" data-x="81" data-y="65" data-w="20">
            </div>

            <div id="pageCounter">Page 1</div>
        </div>
    </div>

</div>

<script>
// Minimal clickmap & highlights + back-button and book overlay
const scene = document.getElementById("scene");
const mask = document.getElementById("mask");
const highlightBookOne = document.getElementById("highlightBookOne");
const highlightBack = document.getElementById("highlightBack");
const bookOverlay = document.getElementById("bookOverlay");

const canvas = document.createElement("canvas");
const ctx = canvas.getContext("2d");

let bookOpen = false;

function drawMaskToCanvas() {
    if (!mask.naturalWidth || !mask.naturalHeight) return;
    canvas.width = mask.naturalWidth;
    canvas.height = mask.naturalHeight;
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.drawImage(mask, 0, 0);
}

// Pages management
const bookPages = document.getElementById('bookPages');
const pages = bookPages ? Array.from(bookPages.querySelectorAll('.page')) : [];
let currentPage = 0;

function showPage(i) {
    if (!pages.length) return;
    if (i < 0 || i >= pages.length) return;
    pages.forEach(p => p.style.display = 'none');
    pages[i].style.display = 'block';
    currentPage = i;
    // position/scale only active items
    positionItems();
    scaleItems();
    const pc = document.getElementById('pageCounter');
    if (pc) pc.textContent = `Page ${currentPage + 1}`;
}

function openPages() {
    if (!pages.length) return;
    showPage(0);
    bookPages.style.pointerEvents = 'none';
}

function closePages() {
    pages.forEach(p => p.style.display = 'none');
}

function nextPage() {
    if (currentPage < pages.length - 1) showPage(currentPage + 1);
}

function prevPage() {
    if (currentPage > 0) showPage(currentPage - 1);
}

function syncHighlightsToScene() {
    const rect = scene.getBoundingClientRect();
    [highlightBookOne, highlightBack].forEach(h => {
        h.style.left = rect.left + 'px';
        h.style.top = rect.top + 'px';
        h.style.width = rect.width + 'px';
        h.style.height = rect.height + 'px';
        h.style.transform = 'none';
        h.style.pointerEvents = 'none';
        h.style.display = 'block';
        h.style.visibility = 'visible';
    });
}

// Scene wrapper syncing: size/position the wrapper to the visible image area (scene or overlay)
const sceneWrapper = document.getElementById('sceneWrapper');
function syncSceneWrapper(full = false) {
    const rect = full && bookOverlay.getBoundingClientRect().width ? bookOverlay.getBoundingClientRect() : scene.getBoundingClientRect();
    sceneWrapper.style.left = rect.left + 'px';
    sceneWrapper.style.top = rect.top + 'px';
    sceneWrapper.style.width = rect.width + 'px';
    sceneWrapper.style.height = rect.height + 'px';
}

// Position and scale arbitrary .item elements relative to an inset content area inside the sceneWrapper
function positionItems() {
    const rect = sceneWrapper.getBoundingClientRect();

    // Define safe inset so items don't drift into image margins/letterboxing
    const insetX = rect.width * 0.06; // 6% inset left/right
    const insetY = rect.height * 0.08; // 8% inset top/bottom

    const contentLeft = 0 + insetX; // relative to wrapper (we'll position absolutely inside wrapper)
    const contentTop = 0 + insetY;
    const contentWidth = Math.max(0, rect.width - insetX * 2);
    const contentHeight = Math.max(0, rect.height - insetY * 2);

    // only position items that are visible (inside the currently displayed page) when pages exist
    let items = [];
    if (pages && pages.length) {
        const visible = pages[currentPage];
        if (visible) items = Array.from(visible.querySelectorAll('.item'));
    }
    if (!items.length) items = Array.from(document.querySelectorAll('.item'));

    items.forEach(el => {
        const x = parseFloat(el.dataset.x) || 50;
        const y = parseFloat(el.dataset.y) || 50;
        const px = contentLeft + contentWidth * (x / 100);
        // Set horizontal centered; vertical will be adjusted after scaling (so it accounts for element height)
        el.style.left = px + 'px';
        // provisional top (kept for immediate layout before scale runs)
        el.style.top = (contentTop + contentHeight * (y / 100)) + 'px';
        // keep translate only on X so top aligns as expected when we adjust for element height
        el.style.transform = 'translate(-50%, 0)';
    });
}

function scaleItems() {
    const rect = sceneWrapper.getBoundingClientRect();
    const insetX = rect.width * 0.06; // match positioning inset
    const insetY = rect.height * 0.08;
    const contentLeft = 0 + insetX;
    const contentTop = 0 + insetY;
    const contentWidth = Math.max(0, rect.width - insetX * 2);
    const contentHeight = Math.max(0, rect.height - insetY * 2);

    // use scene/overlay natural width scaled to contentWidth for font scaling
    const natural = (bookOpen && bookOverlay.naturalWidth) ? bookOverlay.naturalWidth : (scene.naturalWidth || rect.width);
    const scale = natural ? (contentWidth / natural) : 1;

    let items = [];
    if (pages && pages.length) {
        const visible = pages[currentPage];
        if (visible) items = Array.from(visible.querySelectorAll('.item'));
    }
    if (!items.length) items = Array.from(document.querySelectorAll('.item'));

    items.forEach(el => {
        const w = el.dataset.w ? parseFloat(el.dataset.w) : NaN;
        if (!isNaN(w)) {
            el.style.width = (contentWidth * (w / 100)) + 'px';
            el.style.height = 'auto';
        }
        const fs = el.dataset.size ? parseFloat(el.dataset.size) : NaN;
        if (!isNaN(fs)) {
            el.style.fontSize = (fs * scale) + 'px';
        }

        // Now that size is applied, measure height and position vertically taking element height into account.
        const y = parseFloat(el.dataset.y) || 50;
        const elRect = el.getBoundingClientRect();
        const elH = elRect.height;
        // Position top so that y=0 places element's top at contentTop,
        // and y=100 places element's bottom at contentTop+contentHeight.
        const top = contentTop + Math.max(0, contentHeight - elH) * (y / 100);
        el.style.top = top + 'px';
        // Keep horizontal centered
        el.style.transform = 'translate(-50%, 0)';
    });
}

// Position and size the overlay to either fill the scene (full=true) or restore to centered thumbnail
function syncBookOverlayToScene(full = true) {
    const rect = scene.getBoundingClientRect();
    if (full) {
        bookOverlay.style.left = rect.left + 'px';
        bookOverlay.style.top = rect.top + 'px';
        bookOverlay.style.width = rect.width + 'px';
        bookOverlay.style.height = rect.height + 'px';
        bookOverlay.style.transform = 'none';
    } else {
        bookOverlay.style.left = '50%';
        bookOverlay.style.top = '50%';
        bookOverlay.style.transform = 'translate(-50%, -50%)';
        bookOverlay.style.width = '40%';
        bookOverlay.style.height = 'auto';
    }
}

function openBook() {
    syncBookOverlayToScene(true);
    syncSceneWrapper(true);
    bookOverlay.style.opacity = '1';
    // overlay is click-through so scene receives clicks; still show overlay visually
    bookOverlay.style.pointerEvents = 'none';
    bookOpen = true;
    openPages();
    positionItems();
    scaleItems();
}

function closeBook() {
    syncBookOverlayToScene(false);
    syncSceneWrapper(false);
    bookOverlay.style.opacity = '0';
    bookOverlay.style.pointerEvents = 'none';
    bookOpen = false;
    closePages();
    positionItems();
    scaleItems();
}


mask.addEventListener('load', () => { drawMaskToCanvas(); syncHighlightsToScene(); positionItems(); scaleItems(); syncBookOverlayToScene(false); syncSceneWrapper(false); attachItemLoadHandlers(); });
if (mask.complete) { drawMaskToCanvas(); syncHighlightsToScene(); positionItems(); scaleItems(); syncBookOverlayToScene(false); syncSceneWrapper(false); attachItemLoadHandlers(); }

// Also run when the scene image is ready, similar to board.html behavior
scene.addEventListener('load', () => { drawMaskToCanvas(); syncHighlightsToScene(); positionItems(); scaleItems(); syncBookOverlayToScene(false); syncSceneWrapper(false); attachItemLoadHandlers(); });
if (scene.complete) { drawMaskToCanvas(); syncHighlightsToScene(); positionItems(); scaleItems(); syncBookOverlayToScene(false); syncSceneWrapper(false); attachItemLoadHandlers(); }

function getPixelColor(e) {
    const rect = scene.getBoundingClientRect();
    const x = Math.floor((e.clientX - rect.left) * (mask.naturalWidth / rect.width));
    const y = Math.floor((e.clientY - rect.top) * (mask.naturalHeight / rect.height));
    if (x < 0 || y < 0 || x >= canvas.width || y >= canvas.height) return "0,0,0";
    const pixel = ctx.getImageData(x, y, 1, 1).data;
    return `${pixel[0]},${pixel[1]},${pixel[2]}`;
}

// Ensure item images trigger rescaling when their image data is available
function attachItemLoadHandlers() {
    document.querySelectorAll('.item').forEach(img => {
        img.addEventListener('load', () => {
            // scale and position when assets are ready
            positionItems();
            scaleItems();
        });
        // if already loaded, make sure sizing is applied
        if (img.complete) {
            positionItems();
            scaleItems();
        }
    });
}

scene.addEventListener('mousemove', (e) => {
    const color = getPixelColor(e);
    if (bookOpen) {
        // while book is open, ignore blue and only show back highlight
        highlightBookOne.style.opacity = 0;
        highlightBack.style.opacity = (color === '255,255,0') ? 1 : 0;
    } else {
        highlightBookOne.style.opacity = (color === '0,0,255') ? 1 : 0;
        highlightBack.style.opacity = (color === '255,255,0') ? 1 : 0;
    }
});
scene.addEventListener('mouseleave', () => {
    highlightBookOne.style.opacity = 0;
    highlightBack.style.opacity = 0;
});

scene.addEventListener('click', (e) => {
    const color = getPixelColor(e);

    // Back button (yellow) always takes priority
    if (color === '255,255,0') {
        if (bookOpen) {
            closeBook();
            return;
        } else {
            window.location.href = 'index.html';
            return;
        }
    }

    // If book is open, clicks on left/right halves flip pages (only if inside the scene rect)
    if (bookOpen) {
        const rect = scene.getBoundingClientRect();
        const inside = e.clientX >= rect.left && e.clientX <= rect.right && e.clientY >= rect.top && e.clientY <= rect.bottom;
        if (inside) {
            const mid = rect.left + rect.width / 2;
            if (e.clientX < mid) prevPage();
            else nextPage();
        }
        return;
    }

    // If not open and user clicked the blue book area, open it
    if (color === '0,0,255' && !bookOpen) {
        openBook();
    }
});

// Overlay is click-through; scene handles clicks while book is open

// Resize handler: keep mask canvas, highlight margins, items and overlay synced to the background
window.addEventListener('resize', () => {
    drawMaskToCanvas();
    syncHighlightsToScene();
    if (bookOpen) {
        syncBookOverlayToScene(true);
        syncSceneWrapper(true);
    } else {
        syncSceneWrapper(false);
    }
    positionItems();
    scaleItems();
});

// Ensure layout is correct on initial load
window.addEventListener('load', () => {
    drawMaskToCanvas();
    syncHighlightsToScene();
    syncSceneWrapper(bookOpen);
    positionItems();
    scaleItems();
    syncBookOverlayToScene(false);
});
</script>

</body>
</html>