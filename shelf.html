<!DOCTYPE html>
<html>
<head>
<style>
    html, body { margin:0; padding:0; background:black; height:100%; width:100%; overflow:hidden; }
    #container { display:flex; justify-content:center; align-items:center; height:100%; width:100%; background:black; position:relative; }
    .layer { position:absolute; max-width:100%; max-height:100%; object-fit:contain; user-select:none; -webkit-user-drag:none; }
    #scene { left:50%; top:50%; transform:translate(-50%,-50%); height:100%; width:auto; display:block; }
    .overlay { opacity:0; pointer-events:none; transition:opacity 0.2s ease-in-out; z-index:2; }

    /* Items that will be positioned/scaled relative to the scene (use data-x, data-y, data-w, data-size)
       Example: <img class="item" src="pic.png" data-x="30" data-y="40" data-w="20"> */
    .item {
        position: absolute;
        z-index: 4;
        transform: translate(-50%, -50%);
        pointer-events: none; /* set to auto if you want items clickable */
    }

    /* Full-screen book overlay (hidden by default) */
    #bookOverlay {
        position: absolute;
        z-index: 999;
        transition: opacity 0.25s ease-in-out;
        opacity: 0;
        pointer-events: none;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        width: 40%;
        height: auto;
        object-fit: contain;
    }
</style>  
</head>
<body>

<div id="container">

    <!-- Background -->
    <img id="scene" class="layer" src="bookshelf.png">
    <img id="mask" class="layer" src="bookshelfclickmap.png" style="display:none;">

    <!-- Hover highlights -->
    <img id="highlightBookOne" class="layer overlay" src="Hibook1.png">
    <img id="highlightBack" class="layer overlay" src="HiBack.png">

    <!-- Book overlay (opens full scene when book is clicked) -->
    <img id="bookOverlay" class="layer" src="book1.png">

</div>

<script>
// Minimal clickmap & highlights + back-button and book overlay
const scene = document.getElementById("scene");
const mask = document.getElementById("mask");
const highlightBookOne = document.getElementById("highlightBookOne");
const highlightBack = document.getElementById("highlightBack");
const bookOverlay = document.getElementById("bookOverlay");

const canvas = document.createElement("canvas");
const ctx = canvas.getContext("2d");

let bookOpen = false;

function drawMaskToCanvas() {
    if (!mask.naturalWidth || !mask.naturalHeight) return;
    canvas.width = mask.naturalWidth;
    canvas.height = mask.naturalHeight;
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.drawImage(mask, 0, 0);
}

function syncHighlightsToScene() {
    const rect = scene.getBoundingClientRect();
    [highlightBookOne, highlightBack].forEach(h => {
        h.style.left = rect.left + 'px';
        h.style.top = rect.top + 'px';
        h.style.width = rect.width + 'px';
        h.style.height = rect.height + 'px';
        h.style.transform = 'none';
        h.style.pointerEvents = 'none';
        h.style.zIndex = 3;
    });
}

// Position and scale arbitrary .item elements relative to the scene image
function positionItems() {
    const rect = scene.getBoundingClientRect();
    document.querySelectorAll('.item').forEach(el => {
        const x = parseFloat(el.dataset.x) || 50;
        const y = parseFloat(el.dataset.y) || 50;
        const px = rect.left + rect.width * (x / 100);
        const py = rect.top + rect.height * (y / 100);
        el.style.left = px + 'px';
        el.style.top = py + 'px';
        el.style.transform = 'translate(-50%, -50%)';
    });
}

function scaleItems() {
    const rect = scene.getBoundingClientRect();
    const scale = scene.naturalWidth ? (rect.width / scene.naturalWidth) : 1;
    document.querySelectorAll('.item').forEach(el => {
        const w = el.dataset.w ? parseFloat(el.dataset.w) : NaN;
        if (!isNaN(w)) {
            el.style.width = (rect.width * (w / 100)) + 'px';
            el.style.height = 'auto';
        }
        const fs = el.dataset.size ? parseFloat(el.dataset.size) : NaN;
        if (!isNaN(fs)) {
            el.style.fontSize = (fs * scale) + 'px';
        }
    });
}

// Position and size the overlay to either fill the scene (full=true) or restore to centered thumbnail
function syncBookOverlayToScene(full = true) {
    const rect = scene.getBoundingClientRect();
    if (full) {
        bookOverlay.style.left = rect.left + 'px';
        bookOverlay.style.top = rect.top + 'px';
        bookOverlay.style.width = rect.width + 'px';
        bookOverlay.style.height = rect.height + 'px';
        bookOverlay.style.transform = 'none';
    } else {
        bookOverlay.style.left = '50%';
        bookOverlay.style.top = '50%';
        bookOverlay.style.transform = 'translate(-50%, -50%)';
        bookOverlay.style.width = '40%';
        bookOverlay.style.height = 'auto';
    }
}

function openBook() {
    syncBookOverlayToScene(true);
    bookOverlay.style.opacity = '1';
    bookOverlay.style.pointerEvents = 'auto';
    bookOpen = true;
}

function closeBook() {
    syncBookOverlayToScene(false);
    bookOverlay.style.opacity = '0';
    bookOverlay.style.pointerEvents = 'none';
    bookOpen = false;
}

mask.addEventListener('load', () => { drawMaskToCanvas(); syncHighlightsToScene(); positionItems(); scaleItems(); syncBookOverlayToScene(false); });
if (mask.complete) { drawMaskToCanvas(); syncHighlightsToScene(); positionItems(); scaleItems(); syncBookOverlayToScene(false); }

function getPixelColor(e) {
    const rect = scene.getBoundingClientRect();
    const x = Math.floor((e.clientX - rect.left) * (mask.naturalWidth / rect.width));
    const y = Math.floor((e.clientY - rect.top) * (mask.naturalHeight / rect.height));
    if (x < 0 || y < 0 || x >= canvas.width || y >= canvas.height) return "0,0,0";
    const pixel = ctx.getImageData(x, y, 1, 1).data;
    return `${pixel[0]},${pixel[1]},${pixel[2]}`;
}

scene.addEventListener('mousemove', (e) => {
    const color = getPixelColor(e);
    if (bookOpen) {
        // while book is open, ignore blue and only show back highlight
        highlightBookOne.style.opacity = 0;
        highlightBack.style.opacity = (color === '255,255,0') ? 1 : 0;
    } else {
        highlightBookOne.style.opacity = (color === '0,0,255') ? 1 : 0;
        highlightBack.style.opacity = (color === '255,255,0') ? 1 : 0;
    }
});
scene.addEventListener('mouseleave', () => {
    highlightBookOne.style.opacity = 0;
    highlightBack.style.opacity = 0;
});

scene.addEventListener('click', (e) => {
    const color = getPixelColor(e);
    if (color === '0,0,255' && !bookOpen) {
        openBook();
    } else if (color === '255,255,0') {
        if (bookOpen) closeBook();
        else window.location.href = 'index.html';
    }
    // other clicks ignored
});

bookOverlay.addEventListener('click', (e) => {
    const color = getPixelColor(e);
    if (color === '255,255,0') {
        closeBook();
    }
    // otherwise do nothing while book is open
});

// Resize handler: keep mask canvas, highlight margins, items and overlay synced to the background
window.addEventListener('resize', () => {
    drawMaskToCanvas();
    syncHighlightsToScene();
    positionItems();
    scaleItems();
    if (bookOpen) syncBookOverlayToScene(true);
});

// Ensure layout is correct on initial load
window.addEventListener('load', () => {
    drawMaskToCanvas();
    syncHighlightsToScene();
    positionItems();
    scaleItems();
    syncBookOverlayToScene(false);
});
</script>

</body>
</html>